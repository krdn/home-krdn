---
phase: 36-log-aggregation
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - src/lib/log-collector/docker-collector.ts
  - src/lib/log-collector/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "실행 중인 Docker 컨테이너에서 로그 스트리밍 가능"
    - "Docker 로그가 LogStorage에 저장됨"
    - "컨테이너별로 로그 수집 시작/중지 가능"
  artifacts:
    - path: "src/lib/log-collector/docker-collector.ts"
      provides: "Docker 로그 수집기 클래스"
      exports: ["DockerLogCollector"]
      min_lines: 80
    - path: "src/lib/log-collector/index.ts"
      provides: "로그 수집기 매니저"
      exports: ["LogCollectorManager", "logCollectorManager"]
  key_links:
    - from: "docker-collector.ts"
      to: "Docker socket API"
      via: "http.request with follow=true"
      pattern: "/containers/.*/logs.*follow=true"
    - from: "docker-collector.ts"
      to: "LogStorage"
      via: "logStorage.write"
      pattern: "logStorage\\.write"
---

<objective>
Docker 컨테이너 로그 실시간 수집기 구현 — Docker socket API로 로그 스트리밍

Purpose: 컨테이너 로그를 실시간으로 수집하여 통합 로그 저장소에 저장
Output: DockerLogCollector 클래스, LogCollectorManager
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/36-log-aggregation/36-RESEARCH.md
@.planning/phases/36-log-aggregation/36-01-SUMMARY.md

@src/lib/docker.ts
@src/types/log.ts
@src/lib/log-storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DockerLogCollector 클래스 구현</name>
  <files>src/lib/log-collector/docker-collector.ts</files>
  <action>
    Docker 컨테이너 로그 스트리밍 수집기 구현:

    1. 기존 docker.ts의 dockerRequest 패턴 참고
    2. Docker logs API 사용: `/containers/{id}/logs?stdout=true&stderr=true&follow=true&timestamps=true&tail=100`

    DockerLogCollector 클래스:
    ```typescript
    interface LogCollector {
      source: LogSource;
      start(): Promise<void>;
      stop(): Promise<void>;
      on(event: 'log', handler: (entry: LogEntry) => void): void;
      on(event: 'error', handler: (error: Error) => void): void;
    }

    class DockerLogCollector implements LogCollector {
      source = 'docker' as const;
      private containerId: string;
      private containerName: string;
      private request: http.ClientRequest | null = null;
      private handlers: { log: Function[]; error: Function[] } = { log: [], error: [] };

      constructor(containerId: string, containerName: string) {}

      async start(): Promise<void> {
        // Docker socket으로 로그 스트림 시작
        // follow=true로 실시간 스트리밍
        // parseDockerLogStream으로 8바이트 헤더 파싱
      }

      stop(): void {
        // request.destroy()로 스트림 정리
      }

      on(event, handler) { this.handlers[event].push(handler); }
    }
    ```

    3. Docker 로그 청크 파싱 함수 (8바이트 헤더 처리):
       - byte 0: stream type (1=stdout, 2=stderr)
       - byte 4-7: message size (Big Endian)
       - byte 8+: message content

    4. 타임스탬프 파싱: Docker timestamps=true 옵션 사용 시 ISO 형식

    RESEARCH.md의 parseDockerLogStream 패턴 참고.
    기존 docker.ts의 DOCKER_SOCKET 환경변수 재사용.
  </action>
  <verify>
    수동 테스트:
    - 실행 중인 컨테이너 ID로 DockerLogCollector 생성
    - start() 호출 후 'log' 이벤트 수신 확인
    - stop() 호출 후 스트림 종료 확인
  </verify>
  <done>DockerLogCollector가 컨테이너 로그를 실시간으로 파싱하여 이벤트 emit</done>
</task>

<task type="auto">
  <name>Task 2: LogCollectorManager 통합</name>
  <files>src/lib/log-collector/index.ts</files>
  <action>
    로그 수집기 관리 매니저 구현:

    1. LogCollectorManager 클래스:
    ```typescript
    class LogCollectorManager {
      private collectors: Map<string, LogCollector> = new Map();
      private logStorage: LogStorage;

      constructor(logStorage: LogStorage) {}

      // 컨테이너 로그 수집 시작
      async startDockerCollector(containerId: string, containerName: string): Promise<void> {
        const collector = new DockerLogCollector(containerId, containerName);
        collector.on('log', (entry) => this.logStorage.write(entry));
        collector.on('error', (err) => logger.error('Docker log error', err));
        await collector.start();
        this.collectors.set(`docker:${containerId}`, collector);
      }

      // 수집 중지
      stopCollector(key: string): void {
        const collector = this.collectors.get(key);
        if (collector) {
          collector.stop();
          this.collectors.delete(key);
        }
      }

      // 모든 수집기 중지 (graceful shutdown)
      stopAll(): void {
        for (const [key, collector] of this.collectors) {
          collector.stop();
        }
        this.collectors.clear();
      }

      // 활성 수집기 목록
      getActiveCollectors(): string[] {
        return Array.from(this.collectors.keys());
      }
    }
    ```

    2. 싱글톤 인스턴스 export:
    ```typescript
    export const logCollectorManager = new LogCollectorManager(logStorage);
    ```

    3. 에러 핸들링: 기존 logger 사용, 수집 실패 시 자동 재시도 없음 (수동 재시작)
  </action>
  <verify>
    수동 테스트:
    - logCollectorManager.startDockerCollector() 호출
    - DB에 로그 저장 확인
    - getActiveCollectors() 목록 확인
    - stopCollector() 호출 후 수집 중지 확인
  </verify>
  <done>LogCollectorManager가 Docker 수집기 관리 및 LogStorage 연동</done>
</task>

</tasks>

<verification>
Plan 완료 전 확인:
- [ ] `npx tsc --noEmit` 성공
- [ ] DockerLogCollector가 컨테이너 로그 수신
- [ ] 8바이트 헤더 파싱 정상 동작
- [ ] LogStorage에 로그 저장됨
- [ ] stopAll() 호출 시 모든 스트림 정리
</verification>

<success_criteria>
- 모든 태스크 완료
- Docker 컨테이너 로그 실시간 수집 동작
- 로그가 DB에 저장됨
- 수집기 시작/중지 제어 가능
- 메모리 누수 없음 (스트림 정리)
</success_criteria>

<output>
완료 후 `.planning/phases/36-log-aggregation/36-02-SUMMARY.md` 생성
</output>
