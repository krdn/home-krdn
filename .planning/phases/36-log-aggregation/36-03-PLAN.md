---
phase: 36-log-aggregation
plan: 03
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - src/lib/log-collector/file-collector.ts
  - src/lib/log-collector/index.ts
  - src/types/websocket.ts
  - src/app/api/ws/route.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "파일 기반 로그(Pino JSON)가 실시간으로 수집됨"
    - "WebSocket으로 로그 구독(subscribe-logs) 가능"
    - "로그 레벨별 필터링이 동작함"
  artifacts:
    - path: "src/lib/log-collector/file-collector.ts"
      provides: "파일 로그 수집기 클래스"
      exports: ["FileLogCollector"]
      min_lines: 60
    - path: "src/types/websocket.ts"
      provides: "로그 WebSocket 메시지 타입"
      contains: "subscribe-logs"
  key_links:
    - from: "file-collector.ts"
      to: "node-tail"
      via: "Tail class"
      pattern: "new Tail"
    - from: "ws/route.ts"
      to: "logCollectorManager"
      via: "subscribe-logs handler"
      pattern: "subscribe-logs"
---

<objective>
파일 기반 로그 수집기 및 WebSocket 실시간 로그 채널 구현

Purpose: 애플리케이션 로그(Pino JSON) 수집 + 클라이언트 실시간 로그 스트리밍
Output: FileLogCollector 클래스, WebSocket 로그 구독 기능
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/36-log-aggregation/36-RESEARCH.md
@.planning/phases/36-log-aggregation/36-01-SUMMARY.md

@src/types/websocket.ts
@src/app/api/ws/route.ts
@src/lib/log-collector/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: FileLogCollector 클래스 구현</name>
  <files>src/lib/log-collector/file-collector.ts, package.json</files>
  <action>
    파일 기반 로그 수집기 구현 (node-tail 사용):

    1. 의존성 설치: `npm install tail @types/tail`
       (node-tail 패키지명은 'tail')

    2. FileLogCollector 클래스:
    ```typescript
    import { Tail } from 'tail';

    class FileLogCollector implements LogCollector {
      source = 'app' as const;
      private filePath: string;
      private tail: Tail | null = null;
      private handlers: { log: Function[]; error: Function[] } = { log: [], error: [] };

      constructor(filePath: string) {
        this.filePath = filePath;
      }

      async start(): Promise<void> {
        this.tail = new Tail(this.filePath, {
          follow: true,        // log rotation 시 자동 재연결
          fromBeginning: false, // 기존 로그 건너뜀
          useWatchFile: true,   // polling 방식 (NFS 호환)
        });

        this.tail.on('line', (line: string) => {
          const entry = this.parsePinoLog(line);
          if (entry) {
            this.handlers.log.forEach(h => h(entry));
          }
        });

        this.tail.on('error', (err: Error) => {
          this.handlers.error.forEach(h => h(err));
        });
      }

      stop(): void {
        if (this.tail) {
          this.tail.unwatch();
          this.tail = null;
        }
      }

      on(event, handler) { this.handlers[event].push(handler); }

      // Pino JSON 로그 파싱
      private parsePinoLog(line: string): LogEntry | null {
        try {
          const log = JSON.parse(line);
          return {
            id: crypto.randomUUID(),
            source: 'app',
            sourceId: log.module || this.filePath,
            level: this.mapPinoLevel(log.level),
            message: log.msg || log.message || line,
            timestamp: new Date(log.time || Date.now()),
            metadata: log,
          };
        } catch {
          // JSON 아닌 라인은 plain text로 처리
          return {
            id: crypto.randomUUID(),
            source: 'app',
            sourceId: this.filePath,
            level: 'info',
            message: line,
            timestamp: new Date(),
          };
        }
      }

      // Pino level number → LogLevel 매핑
      private mapPinoLevel(level: number | string): LogLevel {
        if (typeof level === 'string') return level as LogLevel;
        if (level <= 10) return 'trace';
        if (level <= 20) return 'debug';
        if (level <= 30) return 'info';
        if (level <= 40) return 'warn';
        if (level <= 50) return 'error';
        return 'fatal';
      }
    }
    ```

    3. LogCollectorManager에 startFileCollector 메서드 추가 (index.ts 수정):
    ```typescript
    async startFileCollector(filePath: string): Promise<void> {
      const collector = new FileLogCollector(filePath);
      collector.on('log', (entry) => this.logStorage.write(entry));
      collector.on('error', (err) => logger.error('File log error', err));
      await collector.start();
      this.collectors.set(`file:${filePath}`, collector);
    }
    ```
  </action>
  <verify>
    수동 테스트:
    - 테스트 로그 파일에 라인 추가
    - FileLogCollector가 새 라인 감지
    - Pino JSON 포맷 파싱 확인
  </verify>
  <done>FileLogCollector가 파일 로그를 실시간으로 파싱하여 이벤트 emit</done>
</task>

<task type="auto">
  <name>Task 2: WebSocket 로그 채널 확장</name>
  <files>src/types/websocket.ts, src/app/api/ws/route.ts</files>
  <action>
    WebSocket을 통한 실시간 로그 스트리밍 구현:

    1. src/types/websocket.ts에 로그 메시지 타입 추가:
    ```typescript
    // 클라이언트 → 서버: 로그 구독 요청
    export const WSLogSubscribeMessageSchema = z.object({
      type: z.literal('subscribe-logs'),
      sources: z.array(z.enum(['docker', 'journal', 'app'])).optional(),
      containers: z.array(z.string()).optional(),
      minLevel: z.enum(['trace', 'debug', 'info', 'warn', 'error', 'fatal']).optional(),
      timestamp: z.number(),
    });

    // 서버 → 클라이언트: 로그 데이터
    export const WSLogMessageSchema = z.object({
      type: z.literal('logs'),
      data: z.array(z.object({
        id: z.string(),
        source: z.enum(['docker', 'journal', 'app']),
        sourceId: z.string(),
        level: z.string(),
        message: z.string(),
        timestamp: z.string(), // ISO string
      })),
      timestamp: z.number(),
    });

    // 로그 구독 해제
    export const WSLogUnsubscribeMessageSchema = z.object({
      type: z.literal('unsubscribe-logs'),
      timestamp: z.number(),
    });
    ```

    2. WSClientMessageType, WSServerMessageType enum 업데이트

    3. WSClientMessageSchema discriminatedUnion에 로그 메시지 추가

    4. WSChannel 타입에 'logs' 추가

    5. src/app/api/ws/route.ts 수정:
    - 'subscribe-logs' 핸들러 추가
    - 로그 구독 시 logCollectorManager에서 이벤트 수신
    - 필터링 (source, level) 적용 후 클라이언트에 전송
    - 'unsubscribe-logs' 핸들러 추가

    레벨 필터링: minLevel이 'warn'이면 warn, error, fatal만 전송
    배치 전송: 100ms 단위로 버퍼링하여 전송 (성능 최적화)
  </action>
  <verify>
    수동 테스트 (WebSocket 클라이언트 도구 사용):
    - subscribe-logs 메시지 전송
    - 로그 발생 시 logs 메시지 수신
    - minLevel 필터링 동작 확인
    - unsubscribe-logs로 구독 해제
  </verify>
  <done>WebSocket으로 실시간 로그 구독/스트리밍 가능</done>
</task>

</tasks>

<verification>
Plan 완료 전 확인:
- [ ] `npm install tail @types/tail` 성공
- [ ] `npx tsc --noEmit` 성공
- [ ] FileLogCollector가 파일 변경 감지
- [ ] Pino JSON 로그 파싱 정상 동작
- [ ] WebSocket subscribe-logs 메시지 처리
- [ ] 로그 레벨 필터링 동작
</verification>

<success_criteria>
- 모든 태스크 완료
- 파일 로그 실시간 수집 동작
- WebSocket 로그 구독/스트리밍 동작
- 레벨별 필터링 동작
- 기존 WebSocket 기능에 영향 없음
</success_criteria>

<output>
완료 후 `.planning/phases/36-log-aggregation/36-03-SUMMARY.md` 생성
</output>
