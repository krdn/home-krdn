# Plan 07-01: 알림 인프라 구축

---
phase: 07-alert-system
plan: 01
type: execute
depends_on: []
files_modified:
  - src/types/alert.ts
  - src/stores/alertStore.ts
  - src/lib/alertEngine.ts
  - src/config/constants.ts
---

## Objective

알림 시스템의 핵심 인프라를 구축합니다. 알림 타입 정의, Zustand 기반 상태 관리, 알림 엔진을 구현합니다.

Purpose: 메트릭 기반 알림 감지 및 상태 관리 시스템 구축
Output: 알림 타입, 상태 스토어, 알림 엔진

## Execution Context

@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Tech stack available:**
- Zustand 5.0.9 - 상태 관리
- React Query 5.90.16 - 데이터 페칭
- Radix Toast 1.2.15 - 토스트 UI

**Established patterns:**
- React Query로 데이터 페칭 (useSystemMetrics, useContainers)
- 중앙화된 상수 관리 (src/config/constants.ts)
- Zod로 런타임 타입 검증

**Key files:**
@src/hooks/useSystemMetrics.ts
@src/config/constants.ts
@src/types/system.ts

## Tasks

<task type="auto">
  <name>Task 1: 알림 타입 정의</name>
  <files>src/types/alert.ts</files>
  <action>
알림 시스템의 타입을 정의합니다:

```typescript
// 알림 심각도
export type AlertSeverity = 'info' | 'warning' | 'critical';

// 알림 상태
export type AlertStatus = 'active' | 'acknowledged' | 'resolved';

// 알림 카테고리
export type AlertCategory = 'cpu' | 'memory' | 'disk' | 'container' | 'network';

// 알림 규칙
export interface AlertRule {
  id: string;
  name: string;
  category: AlertCategory;
  condition: {
    metric: string;
    operator: '>' | '<' | '>=' | '<=' | '==';
    threshold: number;
  };
  severity: AlertSeverity;
  enabled: boolean;
  cooldown: number; // 재알림까지 대기 시간 (초)
}

// 알림 인스턴스
export interface Alert {
  id: string;
  ruleId: string;
  ruleName: string;
  category: AlertCategory;
  severity: AlertSeverity;
  status: AlertStatus;
  message: string;
  value: number;
  threshold: number;
  createdAt: Date;
  acknowledgedAt?: Date;
  resolvedAt?: Date;
}
```
  </action>
  <verify>npx tsc --noEmit src/types/alert.ts</verify>
  <done>알림 관련 타입이 정의되고 타입 체크 통과</done>
</task>

<task type="auto">
  <name>Task 2: 알림 상태 스토어 구현</name>
  <files>src/stores/alertStore.ts</files>
  <action>
Zustand로 알림 상태를 관리합니다:

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { Alert, AlertRule, AlertSeverity } from '@/types/alert';

interface AlertState {
  // 알림 목록
  alerts: Alert[];
  // 알림 규칙
  rules: AlertRule[];

  // 알림 액션
  addAlert: (alert: Omit<Alert, 'id' | 'createdAt'>) => void;
  acknowledgeAlert: (id: string) => void;
  resolveAlert: (id: string) => void;
  clearResolvedAlerts: () => void;

  // 규칙 액션
  addRule: (rule: Omit<AlertRule, 'id'>) => void;
  updateRule: (id: string, updates: Partial<AlertRule>) => void;
  deleteRule: (id: string) => void;
  toggleRule: (id: string) => void;

  // 셀렉터
  getActiveAlerts: () => Alert[];
  getAlertsBySeverity: (severity: AlertSeverity) => Alert[];
}

export const useAlertStore = create<AlertState>()(
  persist(
    (set, get) => ({
      alerts: [],
      rules: getDefaultRules(), // 기본 규칙
      // ... 구현
    }),
    { name: 'alert-store' }
  )
);
```

기본 규칙 포함:
- CPU > 90%: critical
- CPU > 70%: warning
- Memory > 90%: critical
- Memory > 80%: warning
- Disk > 95%: critical
- Disk > 85%: warning
  </action>
  <verify>npm run build -- --filter=src/stores/alertStore.ts 또는 npx tsc --noEmit</verify>
  <done>Zustand 스토어가 생성되고 기본 규칙이 포함됨</done>
</task>

<task type="auto">
  <name>Task 3: 알림 엔진 구현</name>
  <files>src/lib/alertEngine.ts, src/config/constants.ts</files>
  <action>
메트릭을 분석하여 알림을 발생시키는 엔진:

```typescript
import type { SystemMetricsData } from '@/hooks/useSystemMetrics';
import type { AlertRule, AlertCategory, Alert } from '@/types/alert';
import { useAlertStore } from '@/stores/alertStore';

// 마지막 알림 시간 추적 (쿨다운용)
const lastAlertTime: Map<string, number> = new Map();

export function evaluateMetrics(
  metrics: SystemMetricsData,
  rules: AlertRule[]
): Omit<Alert, 'id' | 'createdAt'>[] {
  const newAlerts: Omit<Alert, 'id' | 'createdAt'>[] = [];

  for (const rule of rules) {
    if (!rule.enabled) continue;

    const value = getMetricValue(metrics, rule.category, rule.condition.metric);
    if (value === null) continue;

    const triggered = evaluateCondition(value, rule.condition);

    if (triggered && !isInCooldown(rule.id, rule.cooldown)) {
      newAlerts.push({
        ruleId: rule.id,
        ruleName: rule.name,
        category: rule.category,
        severity: rule.severity,
        status: 'active',
        message: formatAlertMessage(rule, value),
        value,
        threshold: rule.condition.threshold,
      });
      lastAlertTime.set(rule.id, Date.now());
    }
  }

  return newAlerts;
}
```

constants.ts에 ALERT_CONFIG 추가:
- DEFAULT_COOLDOWN: 300 (5분)
- MAX_ALERTS: 100
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>알림 엔진이 메트릭을 분석하고 조건 충족 시 알림 생성</done>
</task>

## Verification

```bash
# 타입 체크
npx tsc --noEmit

# 빌드 확인
npm run build

# 테스트 실행
npm run test
```

## Success Criteria

- [ ] Alert 타입이 정의됨 (Alert, AlertRule, AlertSeverity 등)
- [ ] Zustand 스토어가 알림 상태 관리
- [ ] 기본 알림 규칙이 포함됨 (CPU, Memory, Disk)
- [ ] 알림 엔진이 메트릭 평가 로직 포함
- [ ] 쿨다운 메커니즘으로 알림 중복 방지
- [ ] 빌드 및 테스트 성공

## Output

After completion, create `.planning/phases/07-alert-system/07-01-SUMMARY.md`:

# Summary 07-01: 알림 인프라 구축

**Status:** ✅ Complete

## Accomplishments
- Alert 타입 시스템 정의
- Zustand 기반 상태 관리 스토어
- 메트릭 분석 알림 엔진

## Files Created/Modified
- `src/types/alert.ts`
- `src/stores/alertStore.ts`
- `src/lib/alertEngine.ts`
- `src/config/constants.ts`

## Decisions Made
- Zustand persist로 알림 규칙 로컬 저장
- 쿨다운 기반 중복 알림 방지

## Next Step
Ready for 07-02-PLAN.md (알림 규칙 설정 UI)

---
*Created: 2026-01-14*
