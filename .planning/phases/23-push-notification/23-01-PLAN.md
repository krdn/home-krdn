---
phase: 23-push-notification
plan: 01
type: execute
depends_on: [22-01]
files_modified: [prisma/schema.prisma, src/lib/push-service.ts, src/app/api/push/*, src/hooks/usePushNotification.ts, src/components/pwa/NotificationToggle.tsx, public/sw.js]
domain: next-js
---

<objective>
Web Push API 기반 푸시 알림 인프라를 구축하여 실시간 알림을 사용자 디바이스에 전송합니다.

Purpose: 앱이 닫혀있어도 중요 알림(시스템 경고, 팀 초대 등)을 받을 수 있는 푸시 알림 제공
Output: VAPID 설정 + PushSubscription 모델 + 구독 API + 알림 전송 서비스 + 구독 UI
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# 기존 구조 참고
@public/sw.js
@src/lib/alertEngine.ts
@prisma/schema.prisma

**Tech stack available:** Next.js 16, TypeScript, React 19, Prisma 7, web-push
**Established patterns:** App Router, Service Worker (Phase 22), alertEngine 알림 채널
**Constraining decisions:**
- Phase 22: PWA Foundation 완료 (SW 이미 push 이벤트 핸들러 포함)
- HTTPS 필요 (Web Push 요구사항)

**Research findings (2026-01-15):**
- web-push 라이브러리로 VAPID 키 생성 및 푸시 전송
- VAPID: Voluntary Application Server Identification (서버 인증)
- PushSubscription에 endpoint, keys(p256dh, auth) 저장 필요
- 환경변수: NEXT_PUBLIC_VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY

Sources:
- https://www.npmjs.com/package/web-push
- https://blog.designly.biz/push-notifications-in-next-js-with-web-push-a-provider-free-solution
</context>

<tasks>

<task type="auto">
  <name>Task 1: VAPID 키 생성 및 환경 설정</name>
  <files>package.json, scripts/generate-vapid-keys.js, .env.local, .env.example</files>
  <action>
1. web-push 패키지 설치:
```bash
npm install web-push
```

2. scripts/generate-vapid-keys.js 생성:
```javascript
const webpush = require('web-push');

const vapidKeys = webpush.generateVAPIDKeys();

console.log('VAPID Keys Generated:');
console.log('Public Key:', vapidKeys.publicKey);
console.log('Private Key:', vapidKeys.privateKey);
console.log('');
console.log('Add these to your .env.local:');
console.log(`NEXT_PUBLIC_VAPID_PUBLIC_KEY=${vapidKeys.publicKey}`);
console.log(`VAPID_PRIVATE_KEY=${vapidKeys.privateKey}`);
```

3. VAPID 키 생성 및 .env.local에 추가:
```
NEXT_PUBLIC_VAPID_PUBLIC_KEY=<generated_public_key>
VAPID_PRIVATE_KEY=<generated_private_key>
NEXT_PUBLIC_VAPID_SUBJECT=mailto:admin@krdn.dev
```

4. .env.example 업데이트 (키 값 없이 변수명만)
  </action>
  <verify>node scripts/generate-vapid-keys.js 실행, .env.local 설정 확인</verify>
  <done>web-push 설치, VAPID 키 생성, 환경 변수 설정 완료</done>
</task>

<task type="auto">
  <name>Task 2: PushSubscription 모델 및 구독 API</name>
  <files>prisma/schema.prisma, src/app/api/push/subscribe/route.ts, src/app/api/push/unsubscribe/route.ts</files>
  <action>
1. prisma/schema.prisma에 PushSubscription 모델 추가:
```prisma
model PushSubscription {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoint  String   @unique
  p256dh    String   // encryption key
  auth      String   // authentication secret
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}
```

2. User 모델에 관계 추가:
```prisma
pushSubscriptions PushSubscription[]
```

3. 마이그레이션 실행:
```bash
npx prisma migrate dev --name add_push_subscription
npx prisma generate
```

4. src/app/api/push/subscribe/route.ts 생성:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getUserIdFromToken } from '@/lib/auth';

export async function POST(request: NextRequest) {
  try {
    const userId = await getUserIdFromToken(request);
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const subscription = await request.json();
    const { endpoint, keys } = subscription;

    // upsert로 중복 구독 방지
    await prisma.pushSubscription.upsert({
      where: { endpoint },
      update: {
        userId,
        p256dh: keys.p256dh,
        auth: keys.auth,
        updatedAt: new Date(),
      },
      create: {
        userId,
        endpoint,
        p256dh: keys.p256dh,
        auth: keys.auth,
      },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('[Push] Subscribe error:', error);
    return NextResponse.json({ error: 'Failed to subscribe' }, { status: 500 });
  }
}
```

5. src/app/api/push/unsubscribe/route.ts 생성:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getUserIdFromToken } from '@/lib/auth';

export async function POST(request: NextRequest) {
  try {
    const userId = await getUserIdFromToken(request);
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { endpoint } = await request.json();

    await prisma.pushSubscription.deleteMany({
      where: { userId, endpoint },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('[Push] Unsubscribe error:', error);
    return NextResponse.json({ error: 'Failed to unsubscribe' }, { status: 500 });
  }
}
```
  </action>
  <verify>npx prisma migrate dev 성공, API 엔드포인트 접근 가능</verify>
  <done>PushSubscription 모델 생성, 구독/해지 API 구현 완료</done>
</task>

<task type="auto">
  <name>Task 3: 푸시 전송 서비스 및 alertEngine 통합</name>
  <files>src/lib/push-service.ts, src/lib/alertEngine.ts</files>
  <action>
1. src/lib/push-service.ts 생성:
```typescript
import webpush from 'web-push';
import { prisma } from '@/lib/prisma';

// VAPID 설정
webpush.setVapidDetails(
  process.env.NEXT_PUBLIC_VAPID_SUBJECT || 'mailto:admin@krdn.dev',
  process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!,
  process.env.VAPID_PRIVATE_KEY!
);

export interface PushPayload {
  title: string;
  body: string;
  icon?: string;
  badge?: string;
  url?: string;
  tag?: string;
}

// 단일 사용자에게 푸시 전송
export async function sendPushToUser(
  userId: string,
  payload: PushPayload
): Promise<{ success: number; failed: number }> {
  const subscriptions = await prisma.pushSubscription.findMany({
    where: { userId },
  });

  let success = 0;
  let failed = 0;

  for (const sub of subscriptions) {
    try {
      await webpush.sendNotification(
        {
          endpoint: sub.endpoint,
          keys: { p256dh: sub.p256dh, auth: sub.auth },
        },
        JSON.stringify(payload)
      );
      success++;
    } catch (error: any) {
      // 410 Gone: 구독이 만료됨 - 삭제
      if (error.statusCode === 410) {
        await prisma.pushSubscription.delete({ where: { id: sub.id } });
      }
      failed++;
    }
  }

  return { success, failed };
}

// 여러 사용자에게 푸시 전송
export async function sendPushToUsers(
  userIds: string[],
  payload: PushPayload
): Promise<{ success: number; failed: number }> {
  const results = await Promise.all(
    userIds.map((userId) => sendPushToUser(userId, payload))
  );

  return results.reduce(
    (acc, r) => ({
      success: acc.success + r.success,
      failed: acc.failed + r.failed,
    }),
    { success: 0, failed: 0 }
  );
}

// 모든 구독자에게 브로드캐스트
export async function broadcastPush(
  payload: PushPayload
): Promise<{ success: number; failed: number }> {
  const subscriptions = await prisma.pushSubscription.findMany();

  let success = 0;
  let failed = 0;

  for (const sub of subscriptions) {
    try {
      await webpush.sendNotification(
        {
          endpoint: sub.endpoint,
          keys: { p256dh: sub.p256dh, auth: sub.auth },
        },
        JSON.stringify(payload)
      );
      success++;
    } catch (error: any) {
      if (error.statusCode === 410) {
        await prisma.pushSubscription.delete({ where: { id: sub.id } });
      }
      failed++;
    }
  }

  return { success, failed };
}
```

2. alertEngine.ts에 푸시 채널 추가:
- sendPushAlert 함수 추가
- AlertChannel type에 'push' 추가
  </action>
  <verify>npm run build 성공, push-service 함수 export 확인</verify>
  <done>push-service.ts 구현, alertEngine 통합 완료</done>
</task>

<task type="auto">
  <name>Task 4: 클라이언트 구독 훅 및 UI</name>
  <files>src/hooks/usePushNotification.ts, src/components/pwa/NotificationToggle.tsx, public/sw.js</files>
  <action>
1. src/hooks/usePushNotification.ts 생성:
```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';

export function usePushNotification() {
  const [isSupported, setIsSupported] = useState(false);
  const [isSubscribed, setIsSubscribed] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [permission, setPermission] = useState<NotificationPermission>('default');

  useEffect(() => {
    const checkSupport = async () => {
      const supported = 'serviceWorker' in navigator && 'PushManager' in window;
      setIsSupported(supported);

      if (supported) {
        setPermission(Notification.permission);

        const registration = await navigator.serviceWorker.ready;
        const subscription = await registration.pushManager.getSubscription();
        setIsSubscribed(!!subscription);
      }

      setIsLoading(false);
    };

    checkSupport();
  }, []);

  const subscribe = useCallback(async () => {
    if (!isSupported) return false;

    try {
      const permission = await Notification.requestPermission();
      setPermission(permission);

      if (permission !== 'granted') return false;

      const registration = await navigator.serviceWorker.ready;
      const subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY,
      });

      // 서버에 구독 저장
      const response = await fetch('/api/push/subscribe', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(subscription.toJSON()),
      });

      if (response.ok) {
        setIsSubscribed(true);
        return true;
      }
      return false;
    } catch (error) {
      console.error('[Push] Subscribe error:', error);
      return false;
    }
  }, [isSupported]);

  const unsubscribe = useCallback(async () => {
    if (!isSupported) return false;

    try {
      const registration = await navigator.serviceWorker.ready;
      const subscription = await registration.pushManager.getSubscription();

      if (subscription) {
        // 서버에서 구독 삭제
        await fetch('/api/push/unsubscribe', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ endpoint: subscription.endpoint }),
        });

        await subscription.unsubscribe();
        setIsSubscribed(false);
        return true;
      }
      return false;
    } catch (error) {
      console.error('[Push] Unsubscribe error:', error);
      return false;
    }
  }, [isSupported]);

  return {
    isSupported,
    isSubscribed,
    isLoading,
    permission,
    subscribe,
    unsubscribe,
  };
}
```

2. src/components/pwa/NotificationToggle.tsx 생성:
```typescript
'use client';

import { Bell, BellOff, Loader2 } from 'lucide-react';
import { usePushNotification } from '@/hooks/usePushNotification';

export function NotificationToggle() {
  const { isSupported, isSubscribed, isLoading, permission, subscribe, unsubscribe } =
    usePushNotification();

  if (!isSupported) return null;

  const handleToggle = async () => {
    if (isSubscribed) {
      await unsubscribe();
    } else {
      await subscribe();
    }
  };

  return (
    <button
      onClick={handleToggle}
      disabled={isLoading || permission === 'denied'}
      className="flex items-center gap-2 px-3 py-2 text-sm rounded-lg bg-muted hover:bg-muted/80 transition-colors disabled:opacity-50"
      title={permission === 'denied' ? '알림이 브라우저에서 차단되었습니다' : undefined}
    >
      {isLoading ? (
        <Loader2 className="w-4 h-4 animate-spin" />
      ) : isSubscribed ? (
        <Bell className="w-4 h-4 text-primary" />
      ) : (
        <BellOff className="w-4 h-4 text-muted-foreground" />
      )}
      <span>{isSubscribed ? '알림 켜짐' : '알림 꺼짐'}</span>
    </button>
  );
}
```

3. public/sw.js push 이벤트 핸들러 개선:
```javascript
// Push notification 핸들러 개선
self.addEventListener('push', (event) => {
  if (!event.data) return;

  const data = event.data.json();
  const options = {
    body: data.body,
    icon: data.icon || '/icons/icon-192x192.png',
    badge: data.badge || '/icons/icon-192x192.png',
    tag: data.tag || 'default',
    data: { url: data.url || '/' },
    vibrate: [100, 50, 100],
    actions: [
      { action: 'open', title: '열기' },
      { action: 'close', title: '닫기' },
    ],
  };

  event.waitUntil(
    self.registration.showNotification(data.title, options)
  );
});

// 알림 클릭 핸들러
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  if (event.action === 'close') return;

  const url = event.notification.data?.url || '/';
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      for (const client of clientList) {
        if (client.url === url && 'focus' in client) {
          return client.focus();
        }
      }
      if (clients.openWindow) {
        return clients.openWindow(url);
      }
    })
  );
});
```

4. pwa/index.ts 배럴 파일에 NotificationToggle 추가
  </action>
  <verify>npm run build 성공, NotificationToggle 렌더링 확인</verify>
  <done>usePushNotification 훅 구현, NotificationToggle UI 구현 완료</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` 빌드 성공
- [ ] web-push 패키지 설치됨
- [ ] VAPID 키 .env.local에 설정됨
- [ ] PushSubscription 마이그레이션 완료
- [ ] /api/push/subscribe, /api/push/unsubscribe 엔드포인트 동작
- [ ] NotificationToggle 컴포넌트 렌더링됨
</verification>

<success_criteria>

- VAPID 키 생성 및 환경 설정
- PushSubscription Prisma 모델 및 구독 API
- push-service.ts 푸시 전송 서비스
- 클라이언트 구독 훅 및 토글 UI
- Service Worker push/notificationclick 핸들러
</success_criteria>

<output>
After completion, create `.planning/phases/23-push-notification/23-01-SUMMARY.md`
</output>
