# Plan 27-01: Error Classes & Central Handler

## Overview

중앙집중식 에러 핸들링 시스템의 기반을 구축합니다. 커스텀 에러 클래스 계층 구조와 API 라우트용 중앙 에러 핸들러를 구현합니다.

## Goals

1. 타입-세이프한 커스텀 에러 클래스 계층 구조 생성
2. API 라우트용 중앙집중식 에러 핸들러 구현
3. 에러 코드 상수 및 메시지 표준화
4. 에러 로깅 유틸리티 구현

## Tasks

### Task 1: Custom Error Classes

**File**: `src/lib/errors.ts`

커스텀 에러 클래스 계층 구조를 생성합니다.

```typescript
// 기본 앱 에러 클래스
export class AppError extends Error {
  constructor(
    message: string,
    public code: ErrorCode,
    public statusCode: number = 500,
    public details?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// 인증 에러
export class AuthError extends AppError {
  constructor(message: string, code: AuthErrorCode = 'UNAUTHORIZED') {
    super(message, code, code === 'UNAUTHORIZED' ? 401 : 403);
    this.name = 'AuthError';
  }
}

// 검증 에러
export class ValidationError extends AppError {
  constructor(message: string, public field?: string) {
    super(message, 'VALIDATION_ERROR', 400, { field });
    this.name = 'ValidationError';
  }
}

// Not Found 에러
export class NotFoundError extends AppError {
  constructor(resource: string, identifier?: string) {
    super(
      identifier ? `${resource}(${identifier})를 찾을 수 없습니다` : `${resource}를 찾을 수 없습니다`,
      'NOT_FOUND',
      404
    );
    this.name = 'NotFoundError';
  }
}

// 충돌 에러 (중복)
export class ConflictError extends AppError {
  constructor(message: string, public field?: string) {
    super(message, 'CONFLICT', 409, { field });
    this.name = 'ConflictError';
  }
}

// Rate Limit 에러
export class RateLimitError extends AppError {
  constructor(message: string = '요청이 너무 많습니다. 잠시 후 다시 시도해주세요.') {
    super(message, 'RATE_LIMIT', 429);
    this.name = 'RateLimitError';
  }
}

// 외부 서비스 에러
export class ExternalServiceError extends AppError {
  constructor(service: string, originalError?: Error) {
    super(
      `외부 서비스(${service}) 오류가 발생했습니다`,
      'EXTERNAL_SERVICE_ERROR',
      503,
      { service, originalError: originalError?.message }
    );
    this.name = 'ExternalServiceError';
  }
}
```

**Verification**:
- `npm run typecheck` 통과
- 각 에러 클래스가 올바른 statusCode 반환

### Task 2: Error Codes & Messages

**File**: `src/lib/error-codes.ts`

에러 코드 상수 및 사용자 친화적 메시지 매핑을 생성합니다.

```typescript
// 에러 코드 타입 정의
export type AuthErrorCode =
  | 'UNAUTHORIZED'
  | 'FORBIDDEN'
  | 'INVALID_CREDENTIALS'
  | 'TOKEN_EXPIRED'
  | 'TOKEN_INVALID'
  | 'SESSION_EXPIRED';

export type ValidationErrorCode =
  | 'VALIDATION_ERROR'
  | 'INVALID_INPUT'
  | 'MISSING_FIELD'
  | 'INVALID_FORMAT';

export type ResourceErrorCode =
  | 'NOT_FOUND'
  | 'CONFLICT'
  | 'ALREADY_EXISTS';

export type SystemErrorCode =
  | 'INTERNAL_ERROR'
  | 'EXTERNAL_SERVICE_ERROR'
  | 'RATE_LIMIT'
  | 'DATABASE_ERROR';

export type ErrorCode =
  | AuthErrorCode
  | ValidationErrorCode
  | ResourceErrorCode
  | SystemErrorCode;

// 에러 코드별 기본 메시지
export const ERROR_MESSAGES: Record<ErrorCode, string> = {
  // Auth
  UNAUTHORIZED: '인증이 필요합니다',
  FORBIDDEN: '권한이 부족합니다',
  INVALID_CREDENTIALS: '잘못된 인증 정보입니다',
  TOKEN_EXPIRED: '토큰이 만료되었습니다',
  TOKEN_INVALID: '유효하지 않은 토큰입니다',
  SESSION_EXPIRED: '세션이 만료되었습니다',
  // Validation
  VALIDATION_ERROR: '입력값이 올바르지 않습니다',
  INVALID_INPUT: '잘못된 입력입니다',
  MISSING_FIELD: '필수 필드가 누락되었습니다',
  INVALID_FORMAT: '형식이 올바르지 않습니다',
  // Resource
  NOT_FOUND: '리소스를 찾을 수 없습니다',
  CONFLICT: '리소스 충돌이 발생했습니다',
  ALREADY_EXISTS: '이미 존재하는 리소스입니다',
  // System
  INTERNAL_ERROR: '서버 오류가 발생했습니다',
  EXTERNAL_SERVICE_ERROR: '외부 서비스 오류가 발생했습니다',
  RATE_LIMIT: '요청이 너무 많습니다',
  DATABASE_ERROR: '데이터베이스 오류가 발생했습니다',
};
```

**Verification**:
- 모든 ErrorCode가 ERROR_MESSAGES에 매핑됨
- 타입 체크 통과

### Task 3: Central Error Handler

**File**: `src/lib/api-error-handler.ts`

API 라우트에서 사용할 중앙집중식 에러 핸들러를 구현합니다.

```typescript
import { NextResponse } from 'next/server';
import { AppError, ValidationError } from './errors';
import { ERROR_MESSAGES, ErrorCode } from './error-codes';
import { ZodError } from 'zod';

interface ErrorResponse {
  success: false;
  error: string;
  code: ErrorCode;
  details?: Record<string, unknown>;
}

/**
 * API 라우트용 에러 응답 생성 함수
 */
export function createErrorResponse(
  error: unknown,
  defaultMessage: string = '서버 오류가 발생했습니다'
): NextResponse<ErrorResponse> {
  // AppError 계열
  if (error instanceof AppError) {
    return NextResponse.json(
      {
        success: false,
        error: error.message,
        code: error.code,
        details: error.details,
      },
      { status: error.statusCode }
    );
  }

  // Zod 검증 에러
  if (error instanceof ZodError) {
    const firstIssue = error.issues[0];
    return NextResponse.json(
      {
        success: false,
        error: firstIssue.message,
        code: 'VALIDATION_ERROR',
        details: {
          field: firstIssue.path.join('.'),
          issues: error.issues.map(i => ({
            path: i.path.join('.'),
            message: i.message,
          })),
        },
      },
      { status: 400 }
    );
  }

  // JSON 파싱 에러
  if (error instanceof SyntaxError) {
    return NextResponse.json(
      {
        success: false,
        error: '잘못된 요청 본문입니다',
        code: 'INVALID_INPUT',
      },
      { status: 400 }
    );
  }

  // 일반 Error
  if (error instanceof Error) {
    // 프로덕션에서는 내부 에러 메시지 숨김
    const message = process.env.NODE_ENV === 'production'
      ? defaultMessage
      : error.message;

    return NextResponse.json(
      {
        success: false,
        error: message,
        code: 'INTERNAL_ERROR',
      },
      { status: 500 }
    );
  }

  // 알 수 없는 에러
  return NextResponse.json(
    {
      success: false,
      error: defaultMessage,
      code: 'INTERNAL_ERROR',
    },
    { status: 500 }
  );
}

/**
 * API 라우트 핸들러 래퍼 (try-catch 자동화)
 */
export function withErrorHandler<T>(
  handler: () => Promise<NextResponse<T>>
): Promise<NextResponse<T | ErrorResponse>> {
  return handler().catch((error) => {
    logError(error);
    return createErrorResponse(error);
  });
}
```

**Verification**:
- 각 에러 타입별 올바른 응답 생성 확인
- `npm run typecheck` 통과

### Task 4: Error Logging Utility

**File**: `src/lib/error-logger.ts`

구조화된 에러 로깅 유틸리티를 구현합니다.

```typescript
import { AppError } from './errors';

interface ErrorLogContext {
  path?: string;
  method?: string;
  userId?: string;
  requestId?: string;
  [key: string]: unknown;
}

interface ErrorLogEntry {
  timestamp: string;
  level: 'error' | 'warn';
  name: string;
  message: string;
  code?: string;
  statusCode?: number;
  stack?: string;
  context?: ErrorLogContext;
}

/**
 * 구조화된 에러 로깅
 */
export function logError(
  error: unknown,
  context?: ErrorLogContext
): void {
  const entry: ErrorLogEntry = {
    timestamp: new Date().toISOString(),
    level: 'error',
    name: 'UnknownError',
    message: 'Unknown error occurred',
  };

  if (error instanceof AppError) {
    entry.name = error.name;
    entry.message = error.message;
    entry.code = error.code;
    entry.statusCode = error.statusCode;
    entry.stack = error.stack;
    // 4xx 에러는 warn 레벨
    if (error.statusCode >= 400 && error.statusCode < 500) {
      entry.level = 'warn';
    }
  } else if (error instanceof Error) {
    entry.name = error.name;
    entry.message = error.message;
    entry.stack = error.stack;
  }

  if (context) {
    entry.context = context;
  }

  // JSON 형식으로 로깅 (향후 로그 집계 도구와 호환)
  if (entry.level === 'error') {
    console.error(JSON.stringify(entry));
  } else {
    console.warn(JSON.stringify(entry));
  }
}

/**
 * API 라우트 컨텍스트 추출
 */
export function extractRequestContext(
  request: Request
): ErrorLogContext {
  const url = new URL(request.url);
  return {
    path: url.pathname,
    method: request.method,
    // 추후 requestId 미들웨어 추가 시 확장
  };
}
```

**Verification**:
- 로그 출력 형식 확인
- JSON 파싱 가능한 로그 출력

### Task 5: Unit Tests for Error System

**File**: `src/lib/__tests__/errors.test.ts`

에러 시스템 단위 테스트를 작성합니다.

```typescript
import { describe, it, expect } from 'vitest';
import {
  AppError,
  AuthError,
  ValidationError,
  NotFoundError,
  ConflictError,
  RateLimitError,
  ExternalServiceError,
} from '../errors';
import { createErrorResponse } from '../api-error-handler';
import { ZodError, z } from 'zod';

describe('Custom Error Classes', () => {
  describe('AppError', () => {
    it('should create error with correct properties', () => {
      const error = new AppError('Test error', 'INTERNAL_ERROR', 500);
      expect(error.message).toBe('Test error');
      expect(error.code).toBe('INTERNAL_ERROR');
      expect(error.statusCode).toBe(500);
      expect(error.name).toBe('AppError');
    });
  });

  describe('AuthError', () => {
    it('should default to 401 for UNAUTHORIZED', () => {
      const error = new AuthError('Not authenticated');
      expect(error.statusCode).toBe(401);
      expect(error.code).toBe('UNAUTHORIZED');
    });

    it('should use 403 for FORBIDDEN', () => {
      const error = new AuthError('No permission', 'FORBIDDEN');
      expect(error.statusCode).toBe(403);
    });
  });

  describe('ValidationError', () => {
    it('should include field in details', () => {
      const error = new ValidationError('Invalid email', 'email');
      expect(error.statusCode).toBe(400);
      expect(error.details?.field).toBe('email');
    });
  });

  describe('NotFoundError', () => {
    it('should format message with resource and identifier', () => {
      const error = new NotFoundError('User', '123');
      expect(error.message).toBe('User(123)를 찾을 수 없습니다');
      expect(error.statusCode).toBe(404);
    });
  });
});

describe('createErrorResponse', () => {
  it('should handle AppError correctly', async () => {
    const error = new AuthError('Invalid token', 'TOKEN_INVALID');
    const response = createErrorResponse(error);
    const body = await response.json();

    expect(response.status).toBe(401);
    expect(body.success).toBe(false);
    expect(body.code).toBe('TOKEN_INVALID');
  });

  it('should handle ZodError correctly', async () => {
    const schema = z.object({ email: z.string().email() });
    try {
      schema.parse({ email: 'invalid' });
    } catch (error) {
      const response = createErrorResponse(error);
      const body = await response.json();

      expect(response.status).toBe(400);
      expect(body.code).toBe('VALIDATION_ERROR');
      expect(body.details?.field).toBe('email');
    }
  });

  it('should handle SyntaxError as invalid input', async () => {
    const error = new SyntaxError('Unexpected token');
    const response = createErrorResponse(error);
    const body = await response.json();

    expect(response.status).toBe(400);
    expect(body.code).toBe('INVALID_INPUT');
  });

  it('should handle unknown errors safely', async () => {
    const response = createErrorResponse('string error');
    const body = await response.json();

    expect(response.status).toBe(500);
    expect(body.code).toBe('INTERNAL_ERROR');
  });
});
```

**Verification**:
- `npm run test -- src/lib/__tests__/errors.test.ts` 통과

### Task 6: Export & Integration

**File**: `src/lib/index.ts` (또는 개별 export 확인)

새로운 에러 모듈들을 export하고 사용 가능하게 합니다.

```typescript
// src/lib/errors.ts - 기본 export 확인
// src/lib/error-codes.ts - 기본 export 확인
// src/lib/api-error-handler.ts - 기본 export 확인
// src/lib/error-logger.ts - 기본 export 확인
```

**Verification**:
- 각 모듈이 올바르게 import 가능
- `npm run build` 성공

## Dependencies

- Phase 26 완료 (테스트 인프라)

## Verification Checklist

- [ ] Task 1: 커스텀 에러 클래스 구현 완료
- [ ] Task 2: 에러 코드 및 메시지 상수 정의
- [ ] Task 3: 중앙 에러 핸들러 구현
- [ ] Task 4: 에러 로깅 유틸리티 구현
- [ ] Task 5: 단위 테스트 작성 및 통과
- [ ] Task 6: 모듈 export 및 빌드 확인
- [ ] `npm run typecheck` 통과
- [ ] `npm run build` 성공

## Commit Convention

```
feat(27-01): 커스텀 에러 클래스 및 중앙 핸들러 구현
```
