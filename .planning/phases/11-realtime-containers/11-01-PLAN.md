---
phase: 11-realtime-containers
plan: 01
type: execute
depends_on: []
files_modified: [src/types/websocket.ts, src/lib/websocket-server.ts, src/config/constants.ts, src/hooks/useRealtimeContainers.ts]
---

<objective>
Docker 컨테이너 상태를 WebSocket으로 실시간 스트리밍하고, 컨테이너 액션을 WebSocket을 통해 처리하는 기능 구현

Purpose: 폴링 기반의 컨테이너 목록 조회를 WebSocket 실시간 업데이트로 전환하여 즉각적인 상태 반영
Output: startContainersBroadcast 함수, useRealtimeContainers 훅, 완전한 container-action 처리
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 10 패턴 참조 (동일 패턴 적용)
@.planning/phases/10-realtime-metrics/10-01-SUMMARY.md

# 기존 코드 컨텍스트
@src/types/websocket.ts
@src/lib/websocket-server.ts
@src/hooks/useRealtimeMetrics.ts
@src/hooks/useContainers.ts
@src/lib/docker.ts
@src/config/constants.ts

**Tech stack available:** ws, next-ws, Zod, React Query
**Established patterns:**
- 메트릭 브로드캐스트 패턴 (모듈 로드 시 자동 시작)
- WebSocket fallback to polling 패턴
- WebSocket 채널별 전용 훅 패턴 (useRealtimeMetrics)
- WSData → ClientData 변환 레이어 패턴

**Constraining decisions:**
- Phase 10: 서버 시작 시 무조건 브로드캐스트 시작 (구독자 체크 없이 단순 구현)
- Phase 10: WebSocket fallback to polling 기본 활성화 (안정성)
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebSocket 컨테이너 타입 확장 및 브로드캐스트 로직</name>
  <files>src/types/websocket.ts, src/lib/websocket-server.ts, src/config/constants.ts</files>
  <action>
    1. **constants.ts**: WEBSOCKET_CONFIG에 CONTAINERS_BROADCAST_INTERVAL 추가 (POLLING_INTERVALS.CONTAINERS와 동일하게 10000ms)

    2. **websocket.ts**: WSContainersMessageSchema의 data 필드를 확장
       - 기존: {id, name, state, status}
       - 확장: {id, name, image, state, status, ports, created} - ContainerData와 유사하게
       - WSContainersDataSchema 별도 정의하여 재사용 가능하게

    3. **websocket-server.ts**: 컨테이너 브로드캐스트 로직 추가
       - containersBroadcastInterval 변수 추가
       - transformToWSContainersData(): ContainerInfo[] → WSContainersData[] 변환
       - sendCurrentContainers(ws?): 즉시 컨테이너 목록 전송
       - startContainersBroadcast(intervalMs): 주기적 브로드캐스트 시작
       - stopContainersBroadcast(): 브로드캐스트 중지
       - isContainersBroadcastRunning(): 실행 여부 확인
       - handleSubscribe에서 'containers' 채널 구독 시 sendCurrentContainers 호출 추가

    **주의사항:**
    - listContainers() 함수 재사용 (src/lib/docker.ts)
    - metrics 브로드캐스트 패턴 동일하게 적용
    - 모듈 로드 시 자동 시작하지 말고, route.ts에서 startContainersBroadcast 호출 추가
  </action>
  <verify>npx tsc --noEmit (새 파일에 타입 오류 없음), constants.ts에 CONTAINERS_BROADCAST_INTERVAL 존재</verify>
  <done>WSContainersDataSchema 정의됨, startContainersBroadcast/stopContainersBroadcast 함수 구현됨, handleSubscribe에서 containers 채널 처리됨</done>
</task>

<task type="auto">
  <name>Task 2: useRealtimeContainers 훅 구현</name>
  <files>src/hooks/useRealtimeContainers.ts</files>
  <action>
    useRealtimeMetrics 패턴을 참조하여 useRealtimeContainers 훅 구현:

    1. **타입 정의:**
       - UseRealtimeContainersOptions: enableFallback, autoConnect
       - UseRealtimeContainersReturn: containers, summary, loading, error, connectionStatus, source, connect, disconnect, performAction, getLogs

    2. **유틸리티 함수:**
       - transformContainersData(): WSContainersData[] → ContainerData[] 변환
       - calculateSummary(): ContainerData[] → ContainerSummary 계산

    3. **훅 구현:**
       - useWebSocket 훅으로 WebSocket 연결
       - 연결 성공 시 'containers' 채널 구독
       - isContainersMessage 타입 가드 추가 (useWebSocket.ts에)
       - WebSocket 실패 시 기존 useContainers로 폴링 fallback
       - performAction: WebSocket 통해 container-action 메시지 전송
       - getLogs: 기존 HTTP API 유지 (로그는 대용량이라 WebSocket 비적합)

    4. **기존 useContainers와 동일한 반환 형태 유지** (backward compatibility):
       - containers: ContainerData[]
       - summary: ContainerSummary | null
       - loading, error, refetch는 connect로 대체
       - performAction, getLogs 동일

    **주의사항:**
    - useRealtimeMetrics.ts 구조 참조
    - fallback 기본 활성화 (안정성)
    - getLogs는 WebSocket이 아닌 기존 HTTP API 사용 (로그 데이터 크기 때문)
  </action>
  <verify>npx tsc --noEmit (새 파일에 타입 오류 없음), useRealtimeContainers export 확인</verify>
  <done>useRealtimeContainers 훅 구현됨, 기존 useContainers와 동일한 인터페이스 제공, WebSocket 실패 시 폴링 fallback 동작</done>
</task>

<task type="auto">
  <name>Task 3: 컨테이너 액션 WebSocket 처리 및 ws route 통합</name>
  <files>src/lib/websocket-server.ts, src/app/api/ws/route.ts, src/hooks/useWebSocket.ts</files>
  <action>
    1. **websocket-server.ts의 handleContainerAction 구현:**
       - 기존 stub를 실제 Docker 액션으로 교체
       - startContainer, stopContainer, restartContainer 함수 import (src/lib/docker.ts)
       - 액션 실행 후 container-ack 메시지 전송
       - 액션 성공 시 즉시 sendCurrentContainers() 호출하여 전체 구독자에게 업데이트 브로드캐스트

    2. **route.ts에 컨테이너 브로드캐스트 시작 추가:**
       - startMetricsBroadcast 호출 아래에 startContainersBroadcast 호출 추가
       - WEBSOCKET_CONFIG.CONTAINERS_BROADCAST_INTERVAL 사용

    3. **useWebSocket.ts에 isContainersMessage 타입 가드 추가:**
       - isContainersMessage(msg): msg is WSContainersMessage
       - isContainerAckMessage는 이미 존재함

    **주의사항:**
    - Docker 액션은 비동기이므로 await 사용
    - 에러 발생 시 success: false와 message 포함하여 응답
    - 액션 후 즉시 컨테이너 목록 브로드캐스트로 모든 클라이언트 동기화
  </action>
  <verify>npm run build (빌드 성공), route.ts에 startContainersBroadcast 호출 존재</verify>
  <done>handleContainerAction이 실제 Docker 액션 실행, 액션 후 컨테이너 목록 브로드캐스트, route.ts에서 컨테이너 브로드캐스트 자동 시작</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` 성공
- [ ] `npx tsc --noEmit` 새 파일에 타입 오류 없음
- [ ] constants.ts에 CONTAINERS_BROADCAST_INTERVAL 존재
- [ ] websocket-server.ts에 startContainersBroadcast, sendCurrentContainers 함수 존재
- [ ] useRealtimeContainers.ts export 확인
- [ ] route.ts에서 startContainersBroadcast 호출 확인
- [ ] handleContainerAction이 실제 Docker 함수 호출
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors introduced
- 컨테이너 브로드캐스트가 서버 시작 시 자동 시작
- useRealtimeContainers가 기존 useContainers와 동일한 인터페이스 제공
- container-action 메시지로 컨테이너 제어 가능
- Phase 11 complete
  </success_criteria>

<output>
After completion, create `.planning/phases/11-realtime-containers/11-01-SUMMARY.md`:

# Phase 11 Plan 01: Real-time Containers Summary

**[Substantive one-liner]**

## Performance

- **Duration:** X min
- **Started:** [timestamp]
- **Completed:** [timestamp]
- **Tasks:** 3
- **Files modified:** X

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Task Commits

Each task was committed atomically:

1. **Task 1:** `[hash]` (feat)
2. **Task 2:** `[hash]` (feat)
3. **Task 3:** `[hash]` (feat)

**Plan metadata:** `[hash]` (docs: complete plan)

## Files Created/Modified

- `path/to/file` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Deviations from Plan

[If any, or "None - plan executed exactly as written."]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 11 complete (plan 1/1). Ready for Phase 12 (Email Notification)

---
*Phase: 11-realtime-containers*
*Completed: [date]*
</output>
