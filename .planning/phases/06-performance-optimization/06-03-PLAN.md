# Plan 06-03: 렌더링 성능 최적화

---
phase: 06-performance-optimization
plan: 03
type: execute
depends_on: ["06-01"]
files_modified:
  - src/components/charts/MetricsLineChart.tsx
  - src/components/charts/NetworkAreaChart.tsx
  - src/components/admin/ContainerCard.tsx
  - src/components/admin/DashboardStats.tsx
---

## Objective

React.memo, useMemo, useCallback을 적용하여 불필요한 리렌더링을 방지하고 렌더링 성능을 최적화합니다.

Purpose: 컴포넌트 리렌더링 최소화, 메모이제이션으로 계산 비용 절감
Output: 최적화된 컴포넌트들, 향상된 렌더링 성능

## Execution Context

**Codebase context:**
- 차트 컴포넌트들이 데이터 변경 시 전체 리렌더링
- ContainerCard가 목록에서 개별 업데이트 시에도 전체 리렌더링
- DashboardStats가 메트릭 업데이트마다 리렌더링

**Dependencies:**
- 06-01 완료 (React Query 적용으로 데이터 흐름 안정화)

**Design patterns:**
- React.memo로 props 비교
- useMemo로 계산 결과 캐싱
- useCallback으로 함수 참조 안정화

## Context

Phase 6: Performance Optimization의 세 번째(마지막) 계획입니다.

**현재 문제:**
- 5초마다 시스템 메트릭 업데이트 → 전체 대시보드 리렌더링
- 컨테이너 목록 업데이트 → 모든 ContainerCard 리렌더링
- 차트 데이터 변경 → 차트 컴포넌트 완전 재생성

**최적화 포인트:**
- 차트: 데이터 배열 참조 안정화, memo 적용
- ContainerCard: memo 적용, 개별 컨테이너만 업데이트
- DashboardStats: 개별 stat 카드 memo 적용

## Tasks

### Task 1: 차트 컴포넌트 메모이제이션

**File:** `src/components/charts/MetricsLineChart.tsx`, `src/components/charts/NetworkAreaChart.tsx`

**Changes:**
1. React.memo 적용
2. 커스텀 비교 함수로 data 배열 깊은 비교 방지
3. 차트 옵션 useMemo로 캐싱

**Implementation:**
```typescript
import { memo, useMemo } from 'react';

export const MetricsLineChart = memo(function MetricsLineChart({
  data,
  title,
  color,
  unit,
}: MetricsLineChartProps) {
  // 차트 도메인 계산 메모이제이션
  const domain = useMemo(() => {
    if (data.length === 0) return [0, 100];
    const values = data.map(d => d.value);
    return [Math.min(...values) * 0.9, Math.max(...values) * 1.1];
  }, [data]);

  return (/* ... */);
}, (prevProps, nextProps) => {
  // 데이터 길이와 마지막 값만 비교 (성능 최적화)
  return prevProps.data.length === nextProps.data.length &&
    prevProps.data[prevProps.data.length - 1]?.value ===
    nextProps.data[nextProps.data.length - 1]?.value &&
    prevProps.title === nextProps.title;
});
```

**Commit:** `perf(06-03): 차트 컴포넌트 메모이제이션 적용`

### Task 2: ContainerCard 메모이제이션

**File:** `src/components/admin/ContainerCard.tsx` (또는 컨테이너 카드 컴포넌트)

**Changes:**
1. React.memo 적용
2. performAction 콜백 useCallback으로 안정화
3. 개별 컨테이너 상태 변경 시에만 리렌더링

**Implementation:**
```typescript
export const ContainerCard = memo(function ContainerCard({
  container,
  onAction,
}: ContainerCardProps) {
  const handleStart = useCallback(() => onAction(container.id, 'start'), [container.id, onAction]);
  const handleStop = useCallback(() => onAction(container.id, 'stop'), [container.id, onAction]);

  return (/* ... */);
});
```

**Commit:** `perf(06-03): ContainerCard 메모이제이션 적용`

### Task 3: DashboardStats 최적화

**File:** `src/components/admin/DashboardStats.tsx`

**Changes:**
1. 개별 StatCard 컴포넌트 분리 및 memo 적용
2. 값 포맷팅 useMemo 적용
3. 전체 리렌더링 방지

**Implementation:**
```typescript
const StatCard = memo(function StatCard({
  title,
  value,
  icon: Icon,
  color,
}: StatCardProps) {
  return (
    <div className={cn("rounded-lg p-4", color)}>
      <Icon className="h-6 w-6" />
      <p className="text-2xl font-bold">{value}</p>
      <p className="text-sm text-muted-foreground">{title}</p>
    </div>
  );
});

export function DashboardStats({ data }: DashboardStatsProps) {
  const cpuValue = useMemo(() => `${data.cpu.usage.toFixed(1)}%`, [data.cpu.usage]);
  const memoryValue = useMemo(() => `${data.memory.usage.toFixed(1)}%`, [data.memory.usage]);
  // ...

  return (
    <div className="grid gap-4 md:grid-cols-4">
      <StatCard title="CPU" value={cpuValue} icon={Cpu} color="bg-orange-100" />
      <StatCard title="Memory" value={memoryValue} icon={MemoryStick} color="bg-blue-100" />
      {/* ... */}
    </div>
  );
}
```

**Commit:** `perf(06-03): DashboardStats 컴포넌트 최적화`

## Verification

```bash
# 빌드 확인
npm run build

# 테스트 실행
npm run test

# React DevTools Profiler로 리렌더링 확인
# 1. 개발 서버 실행
npm run dev
# 2. React DevTools 설치 후 Profiler 탭 열기
# 3. 녹화 시작 후 데이터 업데이트 관찰
# 4. 불필요한 리렌더링 없는지 확인
```

## Success Criteria

- [ ] 차트 컴포넌트가 동일 데이터에서 리렌더링되지 않음
- [ ] 개별 컨테이너 업데이트 시 해당 카드만 리렌더링
- [ ] DashboardStats 각 카드가 독립적으로 업데이트
- [ ] 빌드 및 테스트 성공
- [ ] 기존 기능 정상 동작

## Output

**Modified files:**
- `src/components/charts/MetricsLineChart.tsx`
- `src/components/charts/NetworkAreaChart.tsx`
- `src/components/admin/ContainerCard.tsx` (또는 해당 파일)
- `src/components/admin/DashboardStats.tsx`

**Commits:** 3 commits (per task)

---
*Created: 2026-01-14*
