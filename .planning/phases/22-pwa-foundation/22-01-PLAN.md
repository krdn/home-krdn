---
phase: 22-pwa-foundation
plan: 01
type: execute
depends_on: []
files_modified: [app/manifest.ts, public/sw.js, public/icons/*, src/components/pwa/*, next.config.ts, src/app/layout.tsx]
domain: next-js
---

<objective>
PWA 기본 인프라를 구축하여 앱 설치 및 오프라인 기본 지원을 제공합니다.

Purpose: 모바일/데스크톱에서 앱처럼 설치 가능한 PWA 경험 제공
Output: manifest.ts + Service Worker + 설치 프롬프트 UI
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# 기존 구조 참고
@src/app/layout.tsx
@next.config.ts
@src/app/globals.css

**Tech stack available:** Next.js 16, TypeScript, React 19, Zustand, TanStack Query
**Established patterns:** App Router, Server/Client Components, Framer Motion 애니메이션
**Constraining decisions:**
- Phase 21: Team Features 완료 (인증/권한 시스템 구축됨)
- HTTPS 필요 (프로덕션 환경, 개발은 --experimental-https)

**Research findings (2026-01-15):**
- Next.js 16 내장 PWA 지원: app/manifest.ts 자동 감지
- next-pwa deprecated → public/sw.js 직접 작성 권장
- PWA 설치 조건: HTTPS + manifest + SW + 아이콘(192x192, 512x512)
- beforeinstallprompt 이벤트로 설치 프롬프트 커스터마이징

Sources:
- https://nextjs.org/docs/app/guides/progressive-web-apps
- https://gist.github.com/cdnkr/25d3746bdb35767d66c7ae6d26c2ed98
</context>

<tasks>

<task type="auto">
  <name>Task 1: PWA Manifest 및 아이콘 설정</name>
  <files>src/app/manifest.ts, public/icons/icon-192x192.png, public/icons/icon-512x512.png, src/app/layout.tsx</files>
  <action>
1. src/app/manifest.ts 생성 (Next.js 16 내장 기능):
```typescript
import type { MetadataRoute } from 'next'

export default function manifest(): MetadataRoute.Manifest {
  return {
    name: 'Home Dashboard',
    short_name: 'Home',
    description: '홈서버 통합 모니터링 대시보드',
    start_url: '/',
    display: 'standalone',
    background_color: '#0a0a0a',
    theme_color: '#3b82f6',
    orientation: 'portrait-primary',
    icons: [
      {
        src: '/icons/icon-192x192.png',
        sizes: '192x192',
        type: 'image/png',
        purpose: 'any maskable',
      },
      {
        src: '/icons/icon-512x512.png',
        sizes: '512x512',
        type: 'image/png',
        purpose: 'any maskable',
      },
    ],
  }
}
```

2. public/icons/ 디렉토리 생성 및 아이콘 파일 생성:
   - favicon.svg를 기반으로 192x192, 512x512 PNG 생성
   - 간단한 모니터링 아이콘 (대시보드 그래프 형태)
   - 기존 프로젝트 스타일과 일관된 #3b82f6 (primary) 색상

3. layout.tsx 메타데이터 업데이트:
   - themeColor 추가
   - apple-touch-icon 링크 추가
   - viewport meta에 viewport-fit=cover 추가

NOTE: Next.js가 manifest.ts를 자동 감지하므로 별도 link 태그 불필요
  </action>
  <verify>npm run build 성공, /_next/manifest.webmanifest 응답 확인</verify>
  <done>manifest.ts 생성, 아이콘 파일 존재, 메타데이터 업데이트 완료</done>
</task>

<task type="auto">
  <name>Task 2: Service Worker 및 등록 컴포넌트</name>
  <files>public/sw.js, src/components/pwa/ServiceWorkerRegister.tsx, next.config.ts</files>
  <action>
1. public/sw.js 생성 (기본 캐싱 전략):
```javascript
// Service Worker - Basic Caching Strategy
const CACHE_NAME = 'home-dashboard-v1';
const STATIC_ASSETS = [
  '/',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png',
];

// Install: 정적 자산 캐싱
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll(STATIC_ASSETS);
    })
  );
  self.skipWaiting();
});

// Activate: 오래된 캐시 정리
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((keys) =>
      Promise.all(
        keys.filter((key) => key !== CACHE_NAME).map((key) => caches.delete(key))
      )
    )
  );
  self.clients.claim();
});

// Fetch: Network-first 전략 (API), Cache-first (정적 자산)
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);

  // API 요청: Network-first
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(
      fetch(event.request).catch(() =>
        new Response(JSON.stringify({ error: 'Offline' }), {
          status: 503,
          headers: { 'Content-Type': 'application/json' }
        })
      )
    );
    return;
  }

  // 정적 자산: Cache-first
  event.respondWith(
    caches.match(event.request).then((cached) => {
      return cached || fetch(event.request).then((response) => {
        // 성공적인 응답만 캐싱
        if (response.ok && response.type === 'basic') {
          const clone = response.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put(event.request, clone));
        }
        return response;
      });
    })
  );
});

// Push notification (Phase 23에서 활성화)
self.addEventListener('push', (event) => {
  if (!event.data) return;
  const data = event.data.json();
  event.waitUntil(
    self.registration.showNotification(data.title, {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/icon-192x192.png',
    })
  );
});
```

2. src/components/pwa/ServiceWorkerRegister.tsx 생성:
```typescript
'use client';

import { useEffect } from 'react';

export function ServiceWorkerRegister() {
  useEffect(() => {
    if (typeof window === 'undefined') return;
    if (!('serviceWorker' in navigator)) return;

    // 프로덕션에서만 SW 등록 (개발 환경에서는 HMR 방해)
    if (process.env.NODE_ENV === 'production') {
      navigator.serviceWorker
        .register('/sw.js', { scope: '/' })
        .then((registration) => {
          console.log('[SW] Registered:', registration.scope);

          // 업데이트 확인
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            newWorker?.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                console.log('[SW] New version available');
                // 여기서 업데이트 알림 표시 가능
              }
            });
          });
        })
        .catch((error) => {
          console.error('[SW] Registration failed:', error);
        });
    }
  }, []);

  return null;
}
```

3. next.config.ts에 Service Worker 헤더 추가:
```typescript
// headers 함수 내에 추가
{
  source: '/sw.js',
  headers: [
    { key: 'Content-Type', value: 'application/javascript; charset=utf-8' },
    { key: 'Cache-Control', value: 'no-cache, no-store, must-revalidate' },
    { key: 'Service-Worker-Allowed', value: '/' },
  ],
},
```

4. layout.tsx에 ServiceWorkerRegister 추가
  </action>
  <verify>npm run build 성공, /sw.js 접근 가능 (개발 서버에서)</verify>
  <done>sw.js 생성, 등록 컴포넌트 구현, 헤더 설정 완료</done>
</task>

<task type="auto">
  <name>Task 3: PWA 설치 프롬프트 UI</name>
  <files>src/components/pwa/InstallPrompt.tsx, src/hooks/usePWAInstall.ts, src/app/layout.tsx</files>
  <action>
1. src/hooks/usePWAInstall.ts 생성:
```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';

interface BeforeInstallPromptEvent extends Event {
  prompt: () => Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;
}

export function usePWAInstall() {
  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [isInstallable, setIsInstallable] = useState(false);
  const [isInstalled, setIsInstalled] = useState(false);

  useEffect(() => {
    // 이미 설치된 경우 확인
    if (window.matchMedia('(display-mode: standalone)').matches) {
      setIsInstalled(true);
      return;
    }

    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e as BeforeInstallPromptEvent);
      setIsInstallable(true);
    };

    const handleAppInstalled = () => {
      setIsInstalled(true);
      setIsInstallable(false);
      setDeferredPrompt(null);
    };

    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    window.addEventListener('appinstalled', handleAppInstalled);

    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
      window.removeEventListener('appinstalled', handleAppInstalled);
    };
  }, []);

  const install = useCallback(async () => {
    if (!deferredPrompt) return false;

    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;

    setDeferredPrompt(null);
    setIsInstallable(false);

    return outcome === 'accepted';
  }, [deferredPrompt]);

  const dismiss = useCallback(() => {
    setIsInstallable(false);
    setDeferredPrompt(null);
    // 세션 동안 다시 표시하지 않음 (localStorage로 확장 가능)
  }, []);

  return { isInstallable, isInstalled, install, dismiss };
}
```

2. src/components/pwa/InstallPrompt.tsx 생성:
```typescript
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { Download, X } from 'lucide-react';
import { usePWAInstall } from '@/hooks/usePWAInstall';

export function InstallPrompt() {
  const { isInstallable, install, dismiss } = usePWAInstall();

  if (!isInstallable) return null;

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0, y: 100 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: 100 }}
        className="fixed bottom-4 left-4 right-4 md:left-auto md:right-4 md:w-80 z-50"
      >
        <div className="bg-card border border-border rounded-xl p-4 shadow-lg">
          <div className="flex items-start gap-3">
            <div className="flex-shrink-0 p-2 bg-primary/10 rounded-lg">
              <Download className="w-5 h-5 text-primary" />
            </div>
            <div className="flex-1 min-w-0">
              <h3 className="font-semibold text-sm">앱 설치</h3>
              <p className="text-xs text-muted-foreground mt-1">
                홈 화면에 추가하여 더 빠르게 접근하세요
              </p>
              <div className="flex items-center gap-2 mt-3">
                <button
                  onClick={install}
                  className="flex-1 px-3 py-1.5 text-xs bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors"
                >
                  설치하기
                </button>
                <button
                  onClick={dismiss}
                  className="p-1.5 text-muted-foreground hover:text-foreground rounded-lg hover:bg-muted transition-colors"
                >
                  <X className="w-4 h-4" />
                </button>
              </div>
            </div>
          </div>
        </div>
      </motion.div>
    </AnimatePresence>
  );
}
```

3. layout.tsx에 InstallPrompt 추가 (body 내 최하단)

4. src/components/pwa/index.ts 배럴 파일 생성
  </action>
  <verify>npm run build 성공, 개발 서버에서 설치 프롬프트 렌더링 확인</verify>
  <done>usePWAInstall 훅 구현, InstallPrompt UI 구현, layout.tsx 통합 완료</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` 빌드 성공
- [ ] manifest.ts가 /_next/manifest.webmanifest로 제공됨
- [ ] /sw.js 파일 접근 가능
- [ ] 아이콘 파일 (192x192, 512x512) 존재
- [ ] InstallPrompt 컴포넌트 렌더링됨 (조건부)
</verification>

<success_criteria>

- PWA manifest 생성 및 Next.js 자동 연결
- Service Worker 기본 캐싱 전략 구현
- 설치 프롬프트 UI 구현 (beforeinstallprompt 핸들링)
- 프로덕션 빌드 성공
</success_criteria>

<output>
After completion, create `.planning/phases/22-pwa-foundation/22-01-SUMMARY.md`:

# Phase 22-01: PWA Foundation Summary

**[한 줄 요약]**

## Accomplishments
- [구현 내용]

## Files Created/Modified
- `src/app/manifest.ts` - PWA 웹 매니페스트
- `public/sw.js` - Service Worker (기본 캐싱)
- `public/icons/*` - PWA 아이콘
- `src/components/pwa/*` - PWA 컴포넌트
- `src/hooks/usePWAInstall.ts` - 설치 훅
- `next.config.ts` - SW 헤더 추가
- `src/app/layout.tsx` - PWA 컴포넌트 통합

## Decisions Made
[키 결정 및 근거]

## Issues Encountered
[문제점 및 해결책]

## Next Phase Readiness
Phase 22 complete. Phase 23 (Push Notification) 준비 완료.
</output>
