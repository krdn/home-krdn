---
phase: 01-security-foundation
plan: 02
type: execute
depends_on: ["01-01"]
files_modified: [src/app/api/auth/login/route.ts, src/app/api/auth/session/route.ts, src/app/api/auth/logout/route.ts]
---

<objective>
인증 API 엔드포인트를 구현합니다.

Purpose: 사용자가 로그인하고, 세션을 검증하고, 로그아웃할 수 있는 API를 제공합니다.
Output: `/api/auth/login`, `/api/auth/session`, `/api/auth/logout` 엔드포인트
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation/01-01-SUMMARY.md

**Tech available:**
- jose (JWT)
- bcryptjs (password hashing)

**Established patterns:**
- API 라우트 패턴: `src/app/api/system/route.ts` 참조
- NextResponse.json() 사용
- try/catch 에러 핸들링

**Key files:**
@src/lib/auth.ts
@src/types/auth.ts
@src/app/api/system/route.ts (기존 API 패턴 참조)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 로그인 API 엔드포인트 구현</name>
  <files>src/app/api/auth/login/route.ts</files>
  <action>
  POST `/api/auth/login` 엔드포인트 생성:

  **Request body:**
  ```json
  { "username": "admin", "password": "password123" }
  ```

  **로직:**
  1. 요청 body에서 username, password 추출
  2. 환경 변수의 ADMIN_USERNAME과 비교
  3. bcryptjs.compare()로 ADMIN_PASSWORD_HASH와 비교
  4. 일치하면 JWT 생성 (createToken 사용)
  5. httpOnly 쿠키로 JWT 설정 (이름: `auth-token`)
  6. 성공 응답 반환

  **쿠키 설정:**
  - httpOnly: true (XSS 방지)
  - secure: process.env.NODE_ENV === 'production'
  - sameSite: 'lax'
  - path: '/'
  - maxAge: 15 * 60 (15분)

  **응답:**
  - 성공: 200 `{ success: true, user: { username, role } }`
  - 인증 실패: 401 `{ success: false, error: "Invalid credentials" }`
  - 잘못된 요청: 400 `{ success: false, error: "Username and password required" }`

  dynamic = 'force-dynamic' 설정 (캐싱 방지)
  </action>
  <verify>curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"username":"admin","password":"admin123"}' -v 로 Set-Cookie 헤더 확인</verify>
  <done>유효한 자격 증명 → 200 + auth-token 쿠키, 잘못된 자격 증명 → 401</done>
</task>

<task type="auto">
  <name>Task 2: 세션 검증 API 구현</name>
  <files>src/app/api/auth/session/route.ts</files>
  <action>
  GET `/api/auth/session` 엔드포인트 생성:

  **로직:**
  1. 요청 쿠키에서 `auth-token` 추출
  2. verifyToken()으로 JWT 검증
  3. 유효하면 사용자 정보 반환
  4. 무효하면 401 반환

  **응답:**
  - 유효한 세션: 200 `{ authenticated: true, user: { userId, username, role } }`
  - 무효한 세션: 401 `{ authenticated: false, error: "Not authenticated" }`

  클라이언트에서 이 API를 호출하여 로그인 상태를 확인합니다.
  </action>
  <verify>로그인 후 curl http://localhost:3000/api/auth/session --cookie "auth-token=..." 로 사용자 정보 반환 확인</verify>
  <done>유효한 토큰 → 200 + 사용자 정보, 무효한 토큰 → 401</done>
</task>

<task type="auto">
  <name>Task 3: 로그아웃 API 구현</name>
  <files>src/app/api/auth/logout/route.ts</files>
  <action>
  POST `/api/auth/logout` 엔드포인트 생성:

  **로직:**
  1. auth-token 쿠키를 만료시킴 (maxAge: 0)
  2. 성공 응답 반환

  **쿠키 삭제:**
  - Set-Cookie: auth-token=; Path=/; HttpOnly; Max-Age=0

  **응답:**
  - 성공: 200 `{ success: true, message: "Logged out" }`

  로그아웃은 항상 성공합니다 (이미 로그아웃된 상태여도 OK).
  </action>
  <verify>curl -X POST http://localhost:3000/api/auth/logout -v 로 쿠키 삭제 확인</verify>
  <done>POST 요청 시 auth-token 쿠키가 만료되고 200 응답</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` 성공
- [ ] 로그인 API가 올바른 자격 증명으로 쿠키 설정
- [ ] 로그인 API가 잘못된 자격 증명으로 401 반환
- [ ] 세션 API가 유효한 토큰으로 사용자 정보 반환
- [ ] 로그아웃 API가 쿠키 삭제
</verification>

<success_criteria>
- 모든 tasks 완료
- 인증 플로우 end-to-end 동작
- 에러 케이스 적절히 처리됨
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-02-SUMMARY.md`
</output>
